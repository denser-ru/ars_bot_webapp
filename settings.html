<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Настройки</title>
	<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
	<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
	<script src="https://unpkg.com/@babel/standalone@7.10.3/babel.min.js" crossorigin></script>
	<script src="https://telegram.org/js/telegram-web-app.js"></script>
	<!-- Подключение стилей flatpickr -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
	<!-- Подключение скрипта flatpickr -->
	<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
	<!-- Подключение скрипта локализации для русского языка -->
	<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ru.js"></script>

	<style>
		body {
			color: var(--tg-theme-text-color);
			background: var(--tg-theme-bg-color);
		}

		.hint {
			color: var(--tg-theme-hint-color);
		}

		.link {
			color: var(--tg-theme-link-color);
		}

		.button {
			background: var(--tg-theme-button-color);
			color: var(--tg-theme-button-text-color);
		}
	</style>
</head>
<body>
	<div id="root"></div>

	<script type="text/babel" data-presets="react,stage-3">
		const Settings = () => {
			const [startDate, setStartDate] = React.useState('');
			const [endDate, setEndDate] = React.useState('');
			const [sortBy, setSortBy] = React.useState('date');
			const [isStartDateEnabled, setIsStartDateEnabled] = React.useState(false);
			const [isEndDateEnabled, setIsEndDateEnabled] = React.useState(false);

			React.useEffect(() => {
				const urlParams = new URLSearchParams(window.location.search);
				const encodedSettings = urlParams.get('settings');
				let initialStartDate = '';
				let initialEndDate = '';

				try {
					const decodedSettings = JSON.parse(atob(encodedSettings));
					console.log(decodedSettings);

					if (decodedSettings) {
						if (decodedSettings.start_date) {
							setStartDate(decodedSettings.start_date);
							initialStartDate = decodedSettings.start_date;
							setIsStartDateEnabled(decodedSettings.start_date !== "*");
						}
						if (decodedSettings.end_date) {
							setEndDate(decodedSettings.end_date);
							initialEndDate = decodedSettings.end_date;
							setIsEndDateEnabled(decodedSettings.end_date !== "*");
						}
						if (decodedSettings.sort_by) {
							setSortBy(decodedSettings.sort_by);
						}
					}
				} catch (error) {
					console.error('Ошибка при декодировании настроек:', error);
				}

				const startDateInput = document.getElementById('start_date');
				const fpStartDate = flatpickr(startDateInput, {
					locale: 'ru',
					firstDayOfWeek: 1,
					minDate: '2019-01-01',
					maxDate: new Date(),
					defaultDate: initialStartDate,
					onChange: (selectedDates, dateStr) => {
						setStartDate(dateStr);
					},
				});

				const endDateInput = document.getElementById('end_date');
				const fpEndDate = flatpickr(endDateInput, {
					locale: 'ru',
					firstDayOfWeek: 1,
					minDate: '2019-01-01',
					maxDate: new Date(),
					defaultDate: initialEndDate,
					onChange: (selectedDates, dateStr) => {
						setEndDate(dateStr);
					},
				});

				return () => {
					fpStartDate.destroy();
					fpEndDate.destroy();
				};
			}, []);

			React.useEffect(() => {
				const startDateInput = document.getElementById('start_date');
				startDateInput.disabled = !isStartDateEnabled;
				if (!isStartDateEnabled) {
					startDateInput.value = "*";
				} else {
					startDateInput.value = startDate ? startDate : '';
				}
			}, [isStartDateEnabled, startDate]);

			React.useEffect(() => {
				const endDateInput = document.getElementById('end_date');
				endDateInput.disabled = !isEndDateEnabled;
				if (!isEndDateEnabled) {
					endDateInput.value = "*";
				} else {
					endDateInput.value = endDate ? endDate : '';
				}
			}, [isEndDateEnabled, endDate]);

			const handleSubmit = () => {
				const settings = {
					start_date: isStartDateEnabled ? startDate : "*",
					end_date: isEndDateEnabled ? endDate : "*",
					sort_by: sortBy
				};
				Telegram.WebApp.sendData(JSON.stringify(settings));
			};

			return (
				<div className="container">
					<div className="row justify-content-center">
						<h2 className="text-center mb-6">Настройки</h2>
						<div className="form-group col-md-6">
							<label htmlFor="start_date">Дата начала поиска:</label>
							<br />
							<input
								type="text"
								className="form-control date-input"
								id="start_date"
								name="start_date"
							/>
							<input
								type="checkbox"
								id="enable_start_date"
								checked={isStartDateEnabled}
								onChange={() => setIsStartDateEnabled(!isStartDateEnabled)}
							/>
							<label htmlFor="enable_start_date">Включить</label>
						</div>
						<br />

						<div className="form-group">
							<label htmlFor="end_date">Дата окончания:</label>
							<br />
							<input
								type="text"
								className="form-control date-input"
								id="end_date"
								name="end_date"
							/>
							<input
								type="checkbox"
								id="enable_end_date"
								checked={isEndDateEnabled}
								onChange={() => setIsEndDateEnabled(!isEndDateEnabled)}
							/>
							<label htmlFor="enable_end_date">Включить</label>
						</div>

						<div>
							<p>Сортировка по:</p>
							<input
								type="radio"
								id="date_asc"
								name="sort"
								value="date_asc"
								checked={sortBy === 'date_asc'}
								onChange={() => setSortBy('date_asc')}
							/>
							<label htmlFor="date">По дате ↑ </label>
							<input
								type="radio"
								id="date_desc"
								name="sort"
								value="date_desc"
								checked={sortBy === 'date_desc'}
								onChange={() => setSortBy('date_desc')}
							/>
							<label htmlFor="date">По дате ↓</label>
							<input
								type="radio"
								id="relevance"
								name="sort"
								value="relevance"
								checked={sortBy === 'relevance'}
								onChange={() => setSortBy('relevance')}
							/>
							<label htmlFor="relevance">По релевантности</label>
						</div>
						<button onClick={handleSubmit}>
							Сохранить настройки
						</button>
						<p>
							<span style={{ fontSize: "8px" }}>v_a0.0.018</span>
						</p>
					</div>
				</div>
			);
		};

		const root = ReactDOM.createRoot(document.getElementById("root"));
		root.render(<Settings />);
	</script>
</body>
</html>
